# VLL Search in Run3 dataset

### Organizational structure:
```.
├── AnaCodes
│   └── username
│       └── Analysis Codes folder
│           ├── AnaScript.C -> The main C script
│           ├── AnaScript.h -> The associated header file
│           ├── anaCond.C   -> The input-output handler (variable inputs)
│           ├── ana_test.C  -> For testing codes locally
│           └── cleanup.py  -> Cleaning up the directory (including the .so file)
│
├── CondorSetup
│   ├── createCondorJob.py          -> Submits job for only one sample (folder)
│   ├── runJobsCondor_simulation.sh -> The auto-generated shell script that runs in condor
│   ├── runana.C                    -> It picks the anaCond.C and feeds it the necessary inputs.
│   └── submitCondorJobsInBulk.py   -> Submits condor job for all samples.
│
├── InputJsons -> Contains information about input files.
└── Setup      -> Contains all the extra header files used by AnaScript.C
```

### What does it do? How do I run?
#### *Inside the root prompt ...*
##### `AnaScript.C` and `AnaScript.h`
These two are the core of the entire framework. The templates for these files are generated by running `MakeSelector()` for the `Events` tree from the nanoAOD files. The header file contains the class named `AnaScript` , and the C file utilizes its features event-by-event. Before running the codes, the setup needs to be compiled into a library and it has to be loaded in the ROOT prompt by doing the following.
```
[].L AnaScript.C+ //The "+" creates a physical file which is used later.
```
##### `ana_test.C` and `anaCond.C`
Once the C script is compiled and the library is loaded in the root prompt, `ana_test.C` is used as a driver script to run the analysis. It contains inputs, outputs and the other parameters used by the main script.
```
[].x ana_test.C
```
 `anaCond.C` does the same, but it can take these parameters as arguments. This feature is later used by the condor-job submission step. All the parameters are strings by design, because they are eventually fed from a shell script.
```
[].x anaCond.C("input.root", "output.root", "other-parameters")
```
*Note: Both of these driver scripts need the library preloaded.*
##### `runana.C` 
This is also a driver script which is run inside the ROOT prompt. However, this one does not need a preloaded library. It loads the library itself using `gROOT` and then feeds the necessary parameters to `anaCond.C`  
```
[].x runana.C("input.root", "output.root", "other-parameters", "path-to-the-library-directory")
```
#### *Outside the root prompt ...*
Since `runana.C` is sufficient to load the necessary library and then run the analysis code, it can be run outside the root prompt using a shell command.
```
shell~> root -q -b -l path-to-runana.C("arguments")
```
However, this still requires the arguments. This step is automatized using `runJobsCondor_simulation.sh`.

##### `runJobsCondor_simulation.sh` and the condor scripts
The `.sh` file is a driver script that works outside the ROOT prompt. It is automatically generated by `createCondorJob.py` every-time before submitting a condor job. This script is sent to in the individual CPUs via the `.condor` file along with the input parameters.

The `.condor` file is a set of instructions sent to the individual CPUs to load the correct CMSSW version, and then run the shell script along with the input parameters provided in the file itself.  The trick is to create a `.condor` file which contains instructions for all the jobs. This is achieved using the python scripts. `createCondorJob.py` generates one such `.condor` file containing all the root files from one directory, while `submitCondorJobsInBulk.py` repeats this for all the input directories.

---
##### As a summary, here is the "onion structure" of the entire setup (from the inner-most to the outer-most layer)
```
anaCond.C                   -> Runs the code after loading the library inside ROOT
runana.C                    -> Loads the library and runs anaCond.C inside ROOT
runJobsCondor_simulation.sh -> Runs runana.C from outside root
condor file                 -> Instructions to the CPUs about the shell script and its parameters.
createCondorJobs            -> Submits condor-job for all files kept in one directory.
submitCondorJobsInBulk      -> Repeats above step for all input directories.
```
---

### Keep in mind:
- The condor submission scripts need to be customized depending on how you wish to keep the input files. 
- The paths to the header files in the main C script have to be absolute paths for submitting condor jobs.
- The skimmer keeps all the branches, just does not fill them. This is done to avoid compatibility issues with the header files.
- The tree-maker is used to analyze specific final states. It stores all the event-level variables in a `TTree`, which is to be read by a python script for NN training and plotting. 

### Suggestions to contributors:
- If you are a contributor, make your own branch. I will merge them later when the analysis takes shape.
- Keep your codes inside `./AnaCodes/username`. Edit the `BookHistograms.h` file accordingly.
- Please consult me before changing anything in the `./Setup` directory. 
- Feel free to change anything inside the `./CondorSetup` folder depending on what you want to do and how you are organizing the files.
- Right now, the codes are designed to work with nanoAOD version 9 (while developing the analysis framework), which are produced using `CMSSW_10_3_1`. You are recommended to work in this environment to avoid compatibility issues. We will shift to a newer version later.